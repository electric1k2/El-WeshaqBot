Telegram Bot UI Prompt (aiogram v3) / برومت واجهة مستخدم بوت تيليجرام (aiogram v3)

English Version

Main Menu

Construct an InlineKeyboardMarkup for the main menu containing the buttons:
📂 Services, ℹ️ Help, 🎁 Free Points, ⚙️ Settings, 📊 My Statistics, and 🛠 Admin Panel (the Admin button is added only if the user is an admin). Assign callback_data for each button (e.g. "main:services", "main:help", etc.).

Use a filter or check (for example, compare message.from_user.id to your admin ID or use a custom admin filter) to determine if the user is an admin. Only include the “Admin Panel” button for admins.

Provide handler functions for each main menu button using aiogram decorators (e.g. @router.callback_query(F.data == "main:services") or similar). These handlers will display the corresponding submenu or perform the action for that button.


Services Section (📂 Services)

When the user clicks Services (📂), show a new inline keyboard with two buttons:

📱 Numbers (callback_data="services_numbers") – starts the phone-number booking flow.

📧 Temporary Gmail (callback_data="services_gmail") – responds with "Coming soon ✨".


Implement a callback handler for "services_numbers" that begins the number-booking process. Use a Finite State Machine (FSM) to handle the multi-step flow (for example: selecting service type, choosing country, confirming booking). Define a StatesGroup like:

class NumberBooking(StatesGroup):
    waiting_for_service = State()
    waiting_for_country = State()
    # Add more states as needed (e.g. confirmation)

Set the first state (e.g. waiting_for_service) after the user clicks "Numbers". In each state, create appropriate inline keyboards for the user to make choices, and transition to the next state using await state.set_state(...).

For the Temporary Gmail button, simply reply with the message "Coming soon ✨". For example:

@router.callback_query(F.data == "services_gmail")
async def temp_gmail(callback: CallbackQuery):
    await callback.message.answer("Coming soon ✨")
    await callback.answer()


Settings Section (⚙️ Settings)

Under Settings (⚙️), include a button "Balance & History (💰)" with callback_data="settings_balance".

When clicked, fetch the user’s current balance and recent transactions from your database (for example, from the transactions table). Then send a formatted message showing the balance and a list (or table) of recent transactions.

Example handler outline:

@router.callback_query(F.data == "settings_balance")
async def show_balance(callback: CallbackQuery):
    balance = get_user_balance(user_id)        # Implement this function to query your DB
    transactions = get_recent_transactions(user_id)  # Query the 'transactions' table
    text = f"Your balance: {balance}\nRecent transactions:\n..."
    await callback.message.answer(text)
    await callback.answer()

Make sure to query the database correctly (using your ORM or SQL) and display the results clearly.


My Statistics Section (📊 My Statistics)

When the user clicks My Statistics (📊), display a message containing:

The user’s current balance.

The number of booked numbers by the user.

The date of the last bonus or reward the user received.

The date the user joined the service (account creation or first command).


Retrieve all this information from the user’s record in your database. Send it as a neatly formatted text message, for example:

Balance: X points
Booked numbers: Y
Last bonus: YYYY-MM-DD
Joined: YYYY-MM-DD


Free Points Section (🎁 Free Points)

Under Free Points (🎁), display the list of your bot’s channels (e.g., as bullet points or links) and include a "✅ Verify" button with callback_data="free_verify".

When the user clicks Verify (✅), handle it by checking whether the user is subscribed to each channel (use await bot.get_chat_member(channel_id, user_id) or similar checks). If the user is subscribed to all required channels, grant points (e.g., update their balance in the database) and notify them of success. Otherwise, inform them which subscriptions are missing.

Example handler:

@router.callback_query(F.data == "free_verify")
async def verify_channels(callback: CallbackQuery):
    # Pseudo-code: check each channel
    all_subscribed = True
    for channel_id in channel_list:
        member = await bot.get_chat_member(channel_id, callback.from_user.id)
        if member.status == "left":
            all_subscribed = False
            break
    if all_subscribed:
        add_points_to_user(callback.from_user.id)  # Your logic here
        await callback.answer("All subscriptions verified! Points have been added.", show_alert=True)
    else:
        await callback.answer("Please subscribe to all channels to get points.", show_alert=True)


General Implementation Notes

Use aiogram’s InlineKeyboardMarkup and InlineKeyboardButton to build inline keyboards. Ensure each button has a unique and descriptive callback_data.

Structure your callback_data consistently, for example using a "section:action" format (like "main:services", "settings:balance", etc.) to simplify handling.

Use aiogram’s FSM (StatesGroup and State) to manage multi-step processes such as booking a number. For example, after the user clicks "Numbers", set the state to NumberBooking.waiting_for_service; when that step is done, move to NumberBooking.waiting_for_country, and so on.

Write separate handler functions for each callback/action. For inline buttons, use @router.callback_query(F.data == "..."); for simple text commands or reply buttons, use @router.message(F.text == "...").

Remember to call await callback.answer() in your callback handlers to remove the “loading” animation. (This is a good practice even if you immediately send another message.)

With the above structure and handlers in place, you will have a complete menu-driven interface. Fill in any database calls (for balances, transactions, booking, etc.) and business logic as needed. The code snippets and examples should be adjusted to your actual bot setup and database schema.


النسخة العربية من البرومت

الواجهة الرئيسية

أنشئ لوحة مفاتيح مضمنة من نوع InlineKeyboardMarkup تحتوي على الأزرار التالية:
📂 خدمات، ℹ️ مساعدة، 🎁 نقاط مجانية، ⚙️ الإعدادات، 📊 إحصائيتي، و 🛠 لوحة الأدمن (يظهر فقط زر الأدمن إذا كان المستخدم أدمن). حدِّد قيمة callback_data لكل زر (مثلًا "main:services"، "main:help"، وهكذا).

تحقق من هوية المستخدم لمعادلة هيية الأدمن باستخدام فلتر مخصص أو تحقق برمجياً (مثلاً بمقارنة message.from_user.id مع رقم تعريف الأدمن). إذا كان المستخدم أدمن، أضف زر لوحة الأدمن؛ وإلا استبعاده.

أضف معالجات (handlers) لكل زر في القائمة الرئيسية باستخدام @router.callback_query أو @router.message. ستقوم كل دالة معالجة بإظهار القائمة الفرعية المناسبة أو تنفيذ الإجراء الخاص بالزر.


قسم الخدمات (📂 خدمات)

عند النقر على زر خدمات (📂)، اعرض لوحة مفاتيح جديدة بها زران:

📱 أرقام (callback_data="services_numbers") – يؤدي إلى بدء عملية حجز رقم هاتف.

📧 جيميل مؤقت (callback_data="services_gmail") – يرد برسالة "قريبًا ✨" فقط.


ضع معالجاً للتعامل مع callback_data="services_numbers". في هذا المعالج ابدأ تدفق حجز الرقم باستخدام FSM. أنشئ مجموعة حالات StatesGroup مثل:

class NumberBooking(StatesGroup):
    waiting_for_service = State()
    waiting_for_country = State()
    # إضافة حالات أخرى للحجز حسب الحاجة

ثم بعد ضغط المستخدم على "أرقام"، اضبط الحالة على NumberBooking.waiting_for_service. في كل خطوة، قدم لوحة مفاتيح مطابقة (مثلاً اختيار نوع الخدمة أو الدولة)، ثم استخدم await state.set_state(...) للانتقال إلى الحالة التالية.

بالنسبة للزر جيميل مؤقت، فقط قم بالرد برسالة "قريبًا ✨". على سبيل المثال:

@router.callback_query(F.data == "services_gmail")
async def temp_gmail(callback: CallbackQuery):
    await callback.message.answer("قريبًا ✨")
    await callback.answer()


قسم الإعدادات (⚙️ الإعدادات)

ضمن الإعدادات (⚙️)، أضف زر "الرصيد وسجل المعاملات (💰)" مع callback_data="settings_balance".

عند النقر عليه، يجب على البوت استرجاع الرصيد الحالي للمستخدم وآخر المعاملات المالية من جدول transactions في قاعدة البيانات. ثم أرسل رسالة منسقة تتضمن الرصيد والصفقات الأخيرة.

مثال على معالج:

@router.callback_query(F.data == "settings_balance")
async def show_balance(callback: CallbackQuery):
    balance = get_user_balance(user_id)        # دالة وهمية لاسترجاع الرصيد
    transactions = get_recent_transactions(user_id)  # استعلام عن جدول المعاملات
    text = f"رصيدك الحالي: {balance}\nآخر المعاملات:\n..."
    await callback.message.answer(text)
    await callback.answer()

تأكد من تنفيذ استعلامات قاعدة البيانات بشكل صحيح وعرض البيانات بوضوح.


قسم إحصائيتي (📊 إحصائيتي)

عند النقر على "إحصائيتي (📊)"، اعرض رسالة تحتوي على المعلومات التالية عن المستخدم:

الرصيد الحالي.

عدد الأرقام التي حجزها.

تاريخ آخر مكافأة أو نقطة حصل عليها.

تاريخ انضمام المستخدم (أو تاريخ التسجيل أول مرة).


استخرج هذه البيانات من سجل المستخدم في قاعدة البيانات. واطرحها برسالة نصية مرتبة، على سبيل المثال:

الرصيد: X نقطة
الأرقام المحجوزة: Y
آخر مكافأة: YYYY-MM-DD
انضم في: YYYY-MM-DD


قسم نقاط مجانية (🎁 نقاط مجانية)

ضمن نقاط مجانية (🎁)، اعرض قائمة بقنوات البوت (إن وُجدت) وأضف زر "✅ تحقق" مع callback_data="free_verify".

عند النقر على "تحقق (✅)"، تحقق مما إذا كان المستخدم مشتركاً في جميع هذه القنوات عبر await bot.get_chat_member(channel_id, user_id) أو عن طريق فلتر مخصص. إذا كان المستخدم مشتركاً في جميع القنوات المطلوبة، قم بزيادة نقاطه (تحديث الرصيد) وأرسل رسالة تأكيد. أما إذا كان هناك قنوات لم يشترك بها بعد، فاخبره بذلك.

مثال على معالج:

@router.callback_query(F.data == "free_verify")
async def verify_channels(callback: CallbackQuery):
    all_subscribed = True
    for channel_id in channel_list:
        member = await bot.get_chat_member(channel_id, callback.from_user.id)
        if member.status == "left":
            all_subscribed = False
            break
    if all_subscribed:
        add_points_to_user(callback.from_user.id)  # منطق إضافة النقاط
        await callback.answer("تم التحقق! تم إضافة النقاط.", show_alert=True)
    else:
        await callback.answer("يرجى الاشتراك في جميع القنوات للحصول على النقاط.", show_alert=True)


ملاحظات عامة

استخدم InlineKeyboardMarkup مع InlineKeyboardButton لبناء قوائم الأزرار. حدد callback_data لكل زر بشكل واضح ومميز.

نظّم صياغة callback_data (مثلاً "القسم:الإجراء" مثل "main:services", "settings:balance") لتسهيل فلترة الطلبات.

استخدم حالات FSM (StatesGroup و State) للتعامل مع العمليات متعددة الخطوات مثل حجز رقم. على سبيل المثال، بعد ضغط المستخدم "أرقام"، ضع الحالة إلى NumberBooking.waiting_for_service ثم انتقل في المعالج التالي إلى NumberBooking.waiting_for_country، وهكذا.

أضف معالجات منفصلة لكل زر أو أكشن باستخدام الديكوراتور المناسب (@router.callback_query أو @router.message). وتذكَّر استدعاء await callback.answer() في معالجات الـ callback لإزالة رمز التحميل (التدوير).

مع اكتمال هذه الهيكلية والمعالجات، ستحصل على واجهة مستخدم تفاعلية كاملة. أضف تفاصيل منطقية إضافية بحسب الحاجة (مثل استعلامات قاعدة البيانات وتحديثات الرصيد).


المصادر: تم استخدام توثيق aiogram وأمثلة تعليمية حول InlineKeyboardMarkup وFSM في aiogram لتوضيح كيفية بناء اللوحات والقوائم، وكذلك مثال على فلاتر مخصصة للتحقق من الأدمن.

عايزك تربطها بي سوبا بيس 
دا المعلومات 

https://junrioolwdbyzlvvtxsq.supabase.co



eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imp1bnJpb29sd2RieXpsdnZ0eHNxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc0MzM5ODMsImV4cCI6MjA3MzAwOTk4M30.uMwb7wyvIy740WTjps-n7bCoKFk5f_7hoX4EpmOzIxI

زبط الجدوال القدمة في الداتا بيس الجديدة 
